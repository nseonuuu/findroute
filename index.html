<!DOCTYPE html>
<html lang="ko">
  <head>
    <title>쾌적한 경로탐색</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="styles.css">
    <script type="text/javascript" src="//dapi.kakao.com/v2/maps/sdk.js?appkey=a035643f71b9f10705041cf4f38eb95b&libraries=services,clusterer"></script>
	
  </head>
  <body>
    <div id="route-finder">
        <input type="text" id="start-location" placeholder="출발지를 입력하세요">
        <input type="text" id="end-location" placeholder="목적지를 입력하세요">
        <button onclick="findRoute()">경로 찾기</button>
    </div>
    <div id="route-info"></div>

    <script>

        var container = document.querySelector('.map'); //지도를 담을 영역의 DOM 레퍼런스
        var options = { //지도를 생성할 때 필요한 기본 옵션
                    center: new kakao.maps.LatLng(36.4295023415802, 128.067007021683), //지도의 중심좌표.
                    level: 13 //지도의 레벨(확대, 축소 정도)

        };

        var map = new kakao.maps.Map(container, options); //지도 생성 및 객체 리턴
        var maps = {}; // 모든 지도 객체를 저장할 객체
        



	function geocodeAddress(address, sectionId, callback) {
	    // Kakao Maps 지오코딩 객체 생성 및 주소 변환 로직
	    var geocoder = new kakao.maps.services.Geocoder();
	    var mapContainer = document.querySelector('#' + sectionId + ' .map');
	
	    geocoder.addressSearch(address, function (result, status) {
	        if (status === kakao.maps.services.Status.OK) {
	            var coords = new kakao.maps.LatLng(result[0].y, result[0].x);
	            // 'map' 객체를 'maps[sectionId]'로 변경하여 각 섹션에 맞는 지도 객체 사용
	            var map = maps[sectionId]; 
	            if (!map) {
	                console.error('Map object not found for section:', sectionId);
	                return;
	            }
	            callback(coords, map); // 좌표와 지도 객체 반환
	        } else {
	            console.error('Failed to get coordinates for address:', address);
	        }
	    });
	}



        function findRoute() {
            // 사용자 입력 주소를 좌표로 변환하여 경로 찾기
            var startAddress = document.getElementById('start-location').value;
            var endAddress = document.getElementById('end-location').value;

            geocodeAddress(startAddress, function(startCoords) {
                if (!startCoords) {
                    alert('출발지 주소를 찾을 수 없습니다.');
                    return;
                }

                geocodeAddress(endAddress, function(endCoords) {
                    if (!endCoords) {
                        alert('목적지 주소를 찾을 수 없습니다.');
                        return;
                    }

                    // 여기에 경로 찾기 로직을 추가
                    searchRoute(startCoords, endCoords);
                });
            });
        }

        function searchRoute(startCoords, endCoords) {
            // ODSay API를 사용하여 경로 
            var apiKey = 'YOUR_ODSAY_API_KEY'; // ODSay API 키
            var url = `https://api.odsay.com/v1/api/searchPubTransPathT?SX=${startCoords.getLng()}&SY=${startCoords.getLat()}&EX=${endCoords.getLng()}&EY=${endCoords.getLat()}&apiKey=${apiKey}`;

            fetch(url)
                .then(response => response.json())
                .then(data => {
                    // 경로 정보 처리
                    displayRoute(data);
                })
                .catch(error => console.error('Error:', error));
        }

        function displayRoute(data) {
            // 경로 정보를 화면에 표시하는 함수
            // 예제로 간단한 경로 정보를 출력합니다.
            // 여기에 더 복잡한 로직을 추가하여 사용자에게 상세한 경로 정보를 제공할 수 있습니다.
            var routeInfo = data.result.path[0].info; // 첫 번째 경로의 정보
            var message = `총 거리: ${routeInfo.totalDistance}m, 총 소요시간: ${routeInfo.totalTime}분`;

            // HTML에 경로 정보를 표시
            document.getElementById('route-info').innerHTML = message;
        }

        var protestAreas = [
            // 시위 지역 데이터 예시
        ];

        function checkRouteAgainstProtests(route) {
            // 경로와 시위 지역의 충돌 체크
            // route 객체에는 경로의 각 점에 대한 좌표가 포함되어 있어야 합니다.
            // 여기서는 예시로 간단한 충돌 체크 로직을 구현합니다.

            // 각 경로의 점을 순회하며 시위 지역과의 거리를 비교
            for (let point of route.points) {
                for (let area of protestAreas) {
                    var distance = getDistanceBetweenPoints(point, area);
                    if (distance < area.radius) {
                        return true; // 충돌 발생
                    }
                }
            }
            return false; // 충돌 없음
        }

        function findAlternativeRoute(startCoords, endCoords) {
            // 대체 경로 탐색
            // ODSay API를 다시 호출하여 대체 경로를 요청하는 로직 구현
            // startCoords와 endCoords 사이의 대체 경로를 찾습니다.
        }

        function displayRoute(data) {
            var route = data.result.path[0]; // 첫 번째 경로

            if (checkRouteAgainstProtests(route)) {
                findAlternativeRoute(startCoords, endCoords); // 대체 경로 탐색
            } else {
                // 경로 표시 로직
                // 예: 지도에 경로 표시, 경로 세부 정보 제공 등
            }
        }

        function loadAndPlotData(cityName, sectionId, map) {
            const filename = `RT_${cityCodeMapping[cityName]}_Update.csv`;
            var markers = []; // 섹션별 마커 관리
            var circles = []; // 섹션별 원 관리
            protestAreas = []; // protestAreas 배열 초기화

            fetch(filename)
                .then(response => response.text())
                .then(data => {
                    const results = Papa.parse(data, {
                        header: true,
                        skipEmptyLines: true
                    });

                    results.data.forEach(row => {
                        if (row['관련 지역'] && row['신고 인원']) {
                            let address = row['관련 지역'];
                            address = address.replace(/\s*등\s*$/, '');  
                            address = cityName + " " + address;

                            const population = parseInt(row['신고 인원'], 10);
                            if (isNaN(population)) {
                                console.warn('Invalid population value for address:', address);
                                return;
                            }

                            geocodeAddress(address, sectionId, function (location) {
                                if (!location || isNaN(location.Ma) || isNaN(location.La)) {
                                    console.error('Invalid coordinates for address:', address);
                                    return;
                                }

                                const radius = Math.sqrt(population) * 10;
                                if (isNaN(radius)) {
                                    console.error('Invalid radius value for address:', address);
                                    return;
                                }

                                var circle = new kakao.maps.Circle({
                                    center: new kakao.maps.LatLng(location.Ma, location.La),
                                    radius: radius,
                                    strokeWeight: 2,
                                    strokeColor: '#FF0000',
                                    strokeOpacity: 0.5,
                                    fillColor: '#FF0000',
                                    fillOpacity: 0.05,
                                    map: map
                                });
                                circles.push(circle);

                                var marker = new kakao.maps.Marker({
                                    position: new kakao.maps.LatLng(location.Ma, location.La),
                                    map: map,
                                    title: address
                                });
                                markers.push(marker);

                                // protestAreas 배열에 시위 지역 정보 추가
                                protestAreas.push({
                                    lat: location.Ma,
                                    lng: location.La,
                                    radius: Math.sqrt(population) * 10
                                });
                            });
                        }
                    });

                    var html = '<table class="dataframe">';
                    html += '<thead><tr>';
                    results.meta.fields.forEach(field => {
                        html += '<th>' + field + '</th>';
                    });
                    html += '</tr></thead><tbody>';
                    results.data.forEach(row => {
                        html += '<tr>';
                        results.meta.fields.forEach(field => {
                            html += '<td>' + row[field] + '</td>';
                        }); 
                        html += '</tr>';
                    });
                    html += '</tbody></table>';

                    document.querySelector('#' + sectionId + ' .dataframe-container').innerHTML = html;
                })
                .catch(error => {
                    console.error('Error loading or parsing the CSV:', error);
                });
        }



    </script>

  </body>

</html>


